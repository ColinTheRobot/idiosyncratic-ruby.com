<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Idiosyncratic Ruby</title>
  <subtitle>A 31 Parts Story about Ruby Specialities. A New Post Every Day in May 2015!</subtitle>
  <id>http://idiosyncratic-ruby.com/index/</id>
  <link href="http://idiosyncratic-ruby.com/index/"/>
  <link href="https://feeds.feedburner.com/IdiosyncraticRuby" rel="self"/>
  <updated>2015-05-03T02:00:00+02:00</updated>
  <author>
    <name>Jan Lelis</name>
  </author>
  <entry>
    <title>Ruby, Can You Speak Louder?</title>
    <link rel="alternate" href="http://idiosyncratic-ruby.com/3-ruby-can-you-speak-louder.html"/>
    <id>http://idiosyncratic-ruby.com/3-ruby-can-you-speak-louder.html</id>
    <published>2015-05-03T02:00:00+02:00</published>
    <updated>2015-05-03T02:00:00+02:00</updated>
    <author>
      <name>Jan Lelis</name>
    </author>
    <content type="html">&lt;p&gt;Ruby has some ways to turn on &lt;em&gt;debug mode&lt;/em&gt;, which library authors can use to print out extra information for interested users. But unfortunately, there are multiple &lt;em&gt;debug modes&lt;/em&gt; in Ruby. When to use which one?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Consider you have this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def production_method
  puts "I am doing the right thing part 1"
  # @a is really intereting here
  puts "I am doing the right thing part 2"
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could query the global &lt;code&gt;$DEBUG&lt;/code&gt; variable, which can be toggled when starting the Ruby interpreter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def production_method
  puts "I am doing the right thing part 1"
  $stderr.puts "@a is now: #{@a}" if $DEBUG
  puts "I am doing the right thing part 2"
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But is this the best way? It also could have been:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$stderr.puts "@a is now: #{@a}" if $VERBOSE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$stderr.puts "@a is now: #{@a}" if Library.debug_mode?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And what about:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;warn "@a is now: #{@a}"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruby is a little idiosyncratic here. There is no standard way to signalize "I want to have more information". Ruby has two global debug modes: &lt;em&gt;debug mode&lt;/em&gt; and &lt;em&gt;verbosity mode&lt;/em&gt; and both behave differently. Within Ruby, the current debug mode state can be queried from two global variables:&lt;/p&gt;

&lt;h2 id="global-debug-state"&gt;Global Debug State&lt;/h2&gt;

&lt;p&gt;This table shows the different modes both of them can have:&lt;/p&gt;

&lt;table class="table-15-15-30-X"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Variable&lt;/th&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;CLI-Variable Mirrors¹&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;$DEBUG&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;$-d == true&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Debug mode active&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;$DEBUG&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;false&lt;/code&gt;²&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;$-d == false&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Debug mode inactive&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;$VERBOSE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;$-v == true&lt;/code&gt;&lt;br /&gt;&lt;code&gt;$-w == true&lt;/code&gt;&lt;br /&gt;&lt;code&gt;$-W == 2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Verbosity mode active&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;$VERBOSE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;false&lt;/code&gt;²&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;$-v == false&lt;/code&gt;&lt;br /&gt;&lt;code&gt;$-w == false&lt;/code&gt;&lt;br /&gt;&lt;code&gt;$-W == 1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Medium verbosity mode&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;$VERBOSE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;$-v == nil&lt;/code&gt;&lt;br /&gt;&lt;code&gt;$-w == nil&lt;/code&gt;&lt;br /&gt;&lt;code&gt;$-W == 0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Silent verbosity mode&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;¹ Will be set automatically&lt;br /&gt;
² Default&lt;/p&gt;

&lt;p&gt;Note that the Verbosity mode is different for &lt;code&gt;$VERBOSE == false&lt;/code&gt; and &lt;code&gt;$VERBOSE == nil&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Another side note: While it is possible to change &lt;code&gt;$DEBUG&lt;/code&gt; to an arbitrary value, this is not true for &lt;code&gt;$VERBOSE&lt;/code&gt; - If you assign it a truish value, it will just be set to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What follows is a list of command line options that have an effects on the debug modes:&lt;/p&gt;

&lt;h2 id="command-line-options-for-debug-modes"&gt;Command Line Options for Debug Modes&lt;/h2&gt;

&lt;table class="table-20-20-X"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Option&lt;/th&gt;
      &lt;th&gt;Alias&lt;/th&gt;
      &lt;th&gt;Effects&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;-W2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Sets &lt;code&gt;$VERBOSE&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;-W1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Nothing (&lt;code&gt;$VERBOSE&lt;/code&gt; remains &lt;code&gt;false&lt;/code&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;-W0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Sets &lt;code&gt;$VERBOSE&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;--verbose&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Sets &lt;code&gt;$VERBOSE&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;&lt;br /&gt;Also quits Ruby if no arguments given&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Sets &lt;code&gt;$VERBOSE&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;&lt;br /&gt;Also Prints Ruby version&lt;br /&gt;Also quits Ruby if no arguments given&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;--debug&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;-d&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Sets &lt;code&gt;$DEBUG&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;&lt;br /&gt;Sets &lt;code&gt;$VERBOSE&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A funny thing to note is that &lt;code&gt;-v&lt;/code&gt; is a shortcut for &lt;code&gt;--version&lt;/code&gt; as well as it is one for &lt;code&gt;--verbose&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="verbosity"&gt;Verbosity&lt;/h2&gt;

&lt;p&gt;The only thing that actually changes the behavior of the interpreter is the value of &lt;code&gt;VERBOSE&lt;/code&gt;:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;code&gt;$VERBOSE&lt;/code&gt;&lt;/th&gt;
      &lt;th&gt;Effect&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;Kernel#warn&lt;/code&gt; will output to &lt;code&gt;STDERR&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Interpreter warnings will be printed&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id="what-to-use"&gt;What to Use?&lt;/h2&gt;

&lt;p&gt;Use neither &lt;code&gt;$VERBOSE&lt;/code&gt;, nor &lt;code&gt;$DEBUG&lt;/code&gt;, but to use an instance variable in your library. Or use standard library's logger or some other logging gem. It is easier to understand than relying on the global debug modes.&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;$VERBOSE = true&lt;/code&gt; if you are interested in interpreter warnings.&lt;/p&gt;

&lt;h2 id="further-reading"&gt;Further Reading&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://mislav.uniqpath.com/2011/06/ruby-verbose-mode/"&gt;Verbose mode and warnings&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://api.rubyonrails.org/classes/Kernel.html#method-i-silence_warnings"&gt;Rails' verbosity silencer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.ruby-toolbox.com/categories/Logging"&gt;Ruby Loggers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ruby String Magic</title>
    <link rel="alternate" href="http://idiosyncratic-ruby.com/2-ruby-string-magic.html"/>
    <id>http://idiosyncratic-ruby.com/2-ruby-string-magic.html</id>
    <published>2015-05-02T02:00:00+02:00</published>
    <updated>2015-05-02T02:00:00+02:00</updated>
    <author>
      <name>Jan Lelis</name>
    </author>
    <content type="html">&lt;p&gt;Ruby strings are powerful. You could say, Ruby is build around manipulating strings. There are tons of ways how to work with strings and as of Ruby 2.2.2, &lt;code&gt;String&lt;/code&gt; offers 116 instance methods. Knowing them well can save you a lot of time.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;What follows is a list of 10 lesser known things about strings: Some of them useful, some of them idiosyncratic, some both.&lt;/p&gt;

&lt;h2 id="named-format-strings"&gt;Named Format Strings&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;Btw, Ruby&amp;#39;s format strings can be used with hashes:&amp;#10;&amp;quot;%&amp;lt;language&amp;gt;s: %&amp;lt;author&amp;gt;s&amp;quot; % { language: &amp;quot;Ruby&amp;quot;, author: &amp;quot;matz&amp;quot; } #=&amp;gt; &amp;quot;Ruby: matz&amp;quot;&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/527152031782674432"&gt;October 28, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;h2 id="string-concatenation"&gt;String Concatenation&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;There is a lesser-known syntax for concatenating string literals: &amp;quot;just&amp;quot; &amp;quot;put&amp;quot; &amp;quot;them&amp;quot; &amp;quot;directly&amp;quot;&amp;quot;after&amp;quot; &amp;quot;each&amp;quot; &amp;quot;other&amp;quot;&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/510013718076600320"&gt;September 11, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;h2 id="strings--empty-ranges"&gt;Strings + Empty Ranges&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;Ruby is strange. How can an *empty* range have an effect when applied to a string?&amp;#10;r = 0..-3&amp;#10;r.to_a.empty? #=&amp;gt; true&amp;#10;&amp;quot;Ruby&amp;quot;[r] #=&amp;gt; &amp;quot;Ru&amp;quot;&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/519066888014659584"&gt;October 6, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;h2 id="whitespace-matching"&gt;Whitespace Matching&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;Unicode is full of whitespaces. This is how you match them:&amp;#10;a=&amp;quot;    　&amp;quot; #=&amp;gt; &amp;quot;    　&amp;quot;&amp;#10;a.scan(/\s/).size #=&amp;gt; 1&amp;#10;a.scan(/[[:space:]]/).size #=&amp;gt; 5&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/539440415498579969"&gt;December 1, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;h2 id="stringsucc"&gt;&lt;code&gt;String#succ&lt;/code&gt;&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;Ruby&amp;#39;s weird calculation of string successors:&amp;#10;&amp;quot;9z&amp;quot;.succ #=&amp;gt; &amp;quot;10a&amp;quot;&amp;#10;&amp;quot;z9&amp;quot;.succ #=&amp;gt; &amp;quot;aa0&amp;quot;&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/520230545465548801"&gt;October 9, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;h2 id="stdlib-string-compression"&gt;Stdlib String Compression&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;Simple stdlib string compression:&amp;#10;require &amp;#39;zlib&amp;#39;&amp;#10;s = &amp;quot;Ruby&amp;quot;*99&amp;#10;s.size #=&amp;gt; 396&amp;#10;c = Zlib.deflate(s)&amp;#10;c.size #=&amp;gt; 17&amp;#10;Zlib.inflate(c) == s #=&amp;gt;true&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/511902948805599233"&gt;September 16, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;h2 id="using-regex-groups-in-string"&gt;Using Regex Groups in &lt;code&gt;String#[]&lt;/code&gt;&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;You can use regex incl. captured groups when accessing substrings via the [] method: &amp;quot;#42&amp;quot;[/.(\d+)/, 1] #=&amp;gt; &amp;quot;42&amp;quot;&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/508605294059192320"&gt;September 7, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;h2 id="rexepunion"&gt;&lt;code&gt;Rexep.union&lt;/code&gt;&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;If you have an array of strings, you can automatically generate a regex that matches any the strings: regex = Regexp.union(array_of_strings)&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/510441137254195200"&gt;September 12, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;h2 id="convert-a-string-from-snakecase-to-camelcase"&gt;Convert a String from &lt;em&gt;snake_case&lt;/em&gt; to &lt;em&gt;CamelCase&lt;/em&gt;&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;You can camelize a string (some_string =&amp;gt; SomeString) with:&amp;#10;&amp;quot;some_string&amp;quot;.gsub(/(?:^|_)([a-z])/) do $1.upcase end&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/509330964246720512"&gt;September 9, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;h2 id="convert-a-string-from-camelcase-to-snakecase"&gt;Convert a String from &lt;em&gt;CamelCase&lt;/em&gt; to &lt;em&gt;snake_case&lt;/em&gt;&lt;/h2&gt;

&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;You can snakify a string (SomeString =&amp;gt; some_string) with: &amp;#10;&amp;quot;SomeString&amp;quot;.gsub(/(?&amp;lt;!^)[A-Z]/) do &amp;quot;_#$&amp;amp;&amp;quot; end.downcase&lt;/p&gt;&amp;mdash; Ruby String Magic (@RubyStrings) &lt;a href="https://twitter.com/RubyStrings/status/508995693277904896"&gt;September 8, 2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;

&lt;h2 id="resources"&gt;Resources&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://www.ruby-doc.org/core-2.2.2/String.html"&gt;RDoc: String&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/ruby/ruby/blob/trunk/string.c"&gt;Source: String&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/rubinius/rubinius/blob/master/kernel/common/string.rb"&gt;Rubinus Source: String&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Test Highlights</title>
    <link rel="alternate" href="http://idiosyncratic-ruby.com/1-test-highlights.html"/>
    <id>http://idiosyncratic-ruby.com/1-test-highlights.html</id>
    <published>2015-05-01T02:00:00+02:00</published>
    <updated>2015-05-01T02:00:00+02:00</updated>
    <author>
      <name>Jan Lelis</name>
    </author>
    <content type="html">&lt;p&gt;Compared to other languages, Ruby does not have very good tool support for development. This might not be a problem for many of us, in the end, humans create the code, and not tools.&lt;/p&gt;

&lt;p&gt;Nevertheless, it would be better to have better tools. Or at least valid syntax highlighting. The following table shows popular options for code highlighting, but none of them can manage to properly highlight more advanced Ruby features. Here is the:&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id="syntax-highlighter-comparison"&gt;Syntax Highlighter Comparison&lt;/h2&gt;

&lt;table class="table-45-30-X"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Editor or Syntax Highlighter&lt;/th&gt;
      &lt;th&gt;Version&lt;/th&gt;
      &lt;th&gt;Highlights Ruby Correctly?¹&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://github.com/rubychan/coderay"&gt;coderay&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;1.1.0&lt;/td&gt;
      &lt;td&gt;no. score: 4/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://www.jetbrains.com/ruby/"&gt;ruby mine&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;7.1 RM-141.664&lt;/td&gt;
      &lt;td&gt;no. score: 4/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://github.com/jneen/rouge"&gt;rouge&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;1.8.0&lt;/td&gt;
      &lt;td&gt;no. score: 3/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://www.gnu.org/software/emacs/"&gt;emacs&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;24.3.1&lt;/td&gt;
      &lt;td&gt;no. score: 2/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="http://pygments.org/"&gt;pygments&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;1.6&lt;/td&gt;
      &lt;td&gt;no. score: 2/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://wiki.gnome.org/Apps/Gedit"&gt;gedit&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;3.10.4&lt;/td&gt;
      &lt;td&gt;no. score: 1/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://github.com/PrismJS/prism"&gt;prism.js&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;0.0.1&lt;/td&gt;
      &lt;td&gt;no. score: 1/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://github.com/ccampbell/rainbow"&gt;rainbow.js&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;1.1.9&lt;/td&gt;
      &lt;td&gt;no. score: 1/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://www.gnu.org/software/src-highlite/"&gt;src-highlight&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;3.1.6 (library: 4:0:0)&lt;/td&gt;
      &lt;td&gt;no. score: 1/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://github.com/syntaxhighlighter/syntaxhighlighter"&gt;syntaxhighlighter.js&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;3.0.83&lt;/td&gt;
      &lt;td&gt;no. score: 1/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="http://www.vim.org/"&gt;vim&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;7.4.52&lt;/td&gt;
      &lt;td&gt;no. score: 1/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://atom.io/"&gt;atom&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;0.192.0&lt;/td&gt;
      &lt;td&gt;no. score: 0/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://github.com/isagalaev/highlight.js"&gt;highlight.js&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;8.5&lt;/td&gt;
      &lt;td&gt;no. score: 0/5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href="https://www.sublimetext.com/"&gt;sublime text&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;3 Build 3083&lt;/td&gt;
      &lt;td&gt;no. score: 0/5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;¹ Obviously, passing the test does not necessarily mean that a tool highlights Ruby correctly - but it is an indication.&lt;/p&gt;

&lt;h2 id="the-idiosyncratic-ruby-syntax-highlight-test"&gt;The Idiosyncratic Ruby Syntax Highlight Test&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# # #
# For Reference
42
"String with #{ :interpolation }"
/regex$/
$/

# # #
# TEST CASE 1: Question Marks
# SHOULD BE HIGHLIGHTED AS: Array of Strings - Operator - String - Operator - String

[?', ?(] ?'a':'b'

# # #
# TEST CASE 2: Percent Format
# SHOULD BE HIGHLIGHTED AS: String - Operator - Array of Numbers

"%d %d %d"%[1,2,3]

# # #
# TEST CASE 3: Space-delimited String
# SHOULD BE HIGHLIGHTED AS: String Delimiter - String

% 5 #

# # #
# TEST CASE 4: Multi-line Regex with Global Variable Interpolation
# SHOULD BE HIGHLIGHTED AS: Regex Delimiter - Regex -
#                           Interpolation Character (Optional) -
#                           Global Variable -
#                           Regex Delimiter - Regex Options

/
$$#$/
/omix

# # #
# TEST CASE 5: Nested Heredoc
# SHOULD BE HIGHLIGHTED AS: Method - String Delimiter - Operator -
#                           String Delimiter - String - String Delimiter
#                           String - String Delimiter

puts &amp;lt;&amp;lt;HERE&amp;lt;&amp;lt;&amp;lt;&amp;lt;THERE
foo 42
HERE
bla 43
THERE
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
</feed>
